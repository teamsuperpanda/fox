import 'package:flutter/material.dart';
import 'package:flutter_quill/flutter_quill.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:fox/models/note.dart';
import 'package:fox/services/notes_controller.dart';
import 'package:fox/services/repository.dart';
import 'package:fox/note_detail_page.dart';

class MockRepository implements NoteRepository {
  final List<Note> notes = [];

  @override
  Future<void> init() async {}

  @override
  Future<void> addOrUpdate(Note note) async {
    final index = notes.indexWhere((n) => n.id == note.id);
    if (index >= 0) {
      notes[index] = note;
    } else {
      notes.add(note);
    }
  }

  @override
  Future<void> delete(String id) async {
    notes.removeWhere((n) => n.id == id);
  }

  @override
  Future<List<Note>> getAll() async => notes;

  @override
  Future<Note?> getById(String id) async {
    return notes.firstWhere((n) => n.id == id, orElse: () => throw Exception());
  }

  @override
  Future<void> upsert(Note note) async {
    final index = notes.indexWhere((n) => n.id == note.id);
    if (index >= 0) {
      notes[index] = note;
    } else {
      notes.add(note);
    }
  }

  @override
  Future<void> clear() async {
    notes.clear();
  }
}

void main() {
  group('NoteDetailPage - Integration Tests', () {
    late MockRepository mockRepo;
    late NotesController controller;

    setUp(() {
      mockRepo = MockRepository();
      controller = NotesController(mockRepo);
    });

    test('controller adds new note to repository', () async {
      final note = Note(
        id: 'test-id',
        title: 'New Note',
        content: '{"ops":[{"insert":"Content\\n"}]}',
        pinned: false,
        updatedAt: DateTime.now(),
      );

      final doc = Document();
      await controller.addOrUpdate(
        title: note.title,
        content: doc,
        pinned: note.pinned,
      );

      expect(mockRepo.notes.length, equals(1));
      expect(mockRepo.notes.first.title, equals('New Note'));
    });

    test('controller rejects empty title and content', () async {
      // This validates the business logic that would be called by NoteDetailPage
      // Empty notes should be caught before calling addOrUpdate
      expect(true, isTrue); // Placeholder - validation happens in UI
    });

    test('controller updates existing note', () async {
      final originalNote = Note(
        id: 'test-id',
        title: 'Original',
        content: '{}',
        pinned: false,
        updatedAt: DateTime.now(),
      );

      mockRepo.notes.add(originalNote);

      await controller.addOrUpdate(
        id: 'test-id',
        title: 'Updated',
        content: Document(),
        pinned: true,
      );

      expect(mockRepo.notes.length, equals(1));
      expect(mockRepo.notes.first.title, equals('Updated'));
      expect(mockRepo.notes.first.pinned, isTrue);
    });

    test('controller saves pinned state', () async {
      await controller.addOrUpdate(
        title: 'Pinned Note',
        content: Document(),
        pinned: true,
      );

      final saved = mockRepo.notes.first;
      expect(saved.pinned, isTrue);
      expect(saved.title, equals('Pinned Note'));
    });

    test('controller allows title-only notes', () async {
      await controller.addOrUpdate(
        title: 'Title Only',
        content: Document(),
        pinned: false,
      );

      expect(mockRepo.notes.length, equals(1));
      expect(mockRepo.notes.first.title, equals('Title Only'));
    });

    test('controller cycles through content and title updates', () async {
      // Add initial note
      await controller.addOrUpdate(
        title: 'First',
        content: Document(),
        pinned: false,
      );

      // Get the ID
      final noteId = mockRepo.notes.first.id;

      // Update multiple times
      await controller.addOrUpdate(
        id: noteId,
        title: 'Second',
        content: Document(),
      );

      await controller.addOrUpdate(
        id: noteId,
        title: 'Third',
        content: Document(),
        pinned: true,
      );

      expect(mockRepo.notes.length, equals(1));
      expect(mockRepo.notes.first.title, equals('Third'));
      expect(mockRepo.notes.first.pinned, isTrue);
    });
  });

  group('NoteDetailPage - Pin Toggle Logic', () {
    test('pin state toggles from false to true', () {
      final unpinnedNote = Note(
        id: 'id',
        title: 'Test',
        content: '{}',
        pinned: false,
        updatedAt: DateTime.now(),
      );

      final pinnedNote = unpinnedNote.copyWith(pinned: true);
      expect(pinnedNote.pinned, isTrue);
    });

  group('NoteDetailPage - Widget Tests', () {
    late MockRepository mockRepo;
    late NotesController controller;

    setUp(() {
      mockRepo = MockRepository();
      controller = NotesController(mockRepo);
    });

    testWidgets('creates new note with title and content', (tester) async {
      await tester.pumpWidget(MaterialApp(
        localizationsDelegates: [FlutterQuillLocalizations.delegate],
        home: NoteDetailPage(controller: controller),
      ));

      // Enter title
      await tester.enterText(find.byType(TextField).first, 'New Note Title');
      await tester.pump();

      // Enter content in Quill editor
      final quillEditor = find.byType(QuillEditor);
      expect(quillEditor, findsOneWidget);

      // Tap save
      await tester.tap(find.byIcon(Icons.save));
      await tester.pumpAndSettle();

      // Should navigate back
      expect(find.byType(NoteDetailPage), findsNothing);
      expect(mockRepo.notes.length, 1);
      expect(mockRepo.notes.first.title, 'New Note Title');
    });

    testWidgets('discards empty new note on back', (tester) async {
      await tester.pumpWidget(MaterialApp(
        localizationsDelegates: [FlutterQuillLocalizations.delegate],
        home: NoteDetailPage(controller: controller),
      ));

      // Tap back without entering anything
      await tester.tap(find.byIcon(Icons.arrow_back));
      await tester.pumpAndSettle();

      // Should navigate back without saving
      expect(find.byType(NoteDetailPage), findsNothing);
      expect(mockRepo.notes.length, 0);
    });

    testWidgets('shows error for empty existing note', (tester) async {
      final existingNote = Note(
        id: 'existing',
        title: 'Existing',
        content: '{"ops":[{"insert":"content\\n"}]}',
        pinned: false,
        updatedAt: DateTime.now(),
      );
      mockRepo.notes.add(existingNote);

      await tester.pumpWidget(MaterialApp(
        localizationsDelegates: [FlutterQuillLocalizations.delegate],
        home: NoteDetailPage(existing: existingNote, controller: controller),
      ));

      // Clear title
      final titleField = find.byType(TextField).first;
      await tester.enterText(titleField, '');
      await tester.pump();

      // Tap save
      await tester.tap(find.byIcon(Icons.save));
      await tester.pump();

      // Should show error snackbar
      expect(find.text('Note cannot be empty'), findsOneWidget);
      // Note should not be saved
      expect(mockRepo.notes.length, 1); // still the original
    });

    testWidgets('toggles toolbar visibility', (tester) async {
      await tester.pumpWidget(MaterialApp(
        localizationsDelegates: [FlutterQuillLocalizations.delegate],
        home: NoteDetailPage(controller: controller),
      ));

      // Initially toolbar should be visible
      expect(find.byType(QuillSimpleToolbar), findsOneWidget);

      // Tap toolbar toggle
      await tester.tap(find.byIcon(Icons.text_format));
      await tester.pump();

      // Toolbar should be hidden
      expect(find.byType(QuillSimpleToolbar), findsNothing);

      // Tap again
      await tester.tap(find.byIcon(Icons.text_format_outlined));
      await tester.pump();

      // Toolbar should be visible again
      expect(find.byType(QuillSimpleToolbar), findsOneWidget);
    });
  });

  group('NoteDetailPage - Pin Toggle Logic', () {
    test('pin state toggles from false to true', () {
      final unpinnedNote = Note(
        id: 'id',
        title: 'Test',
        content: '{}',
        pinned: false,
        updatedAt: DateTime.now(),
      );

      final pinnedNote = unpinnedNote.copyWith(pinned: true);
      expect(pinnedNote.pinned, isTrue);
    });

    test('pin state toggles from true to false', () {
      final pinnedNote = Note(
        id: 'id',
        title: 'Test',
        content: '{}',
        pinned: true,
        updatedAt: DateTime.now(),
      );

      final unpinnedNote = pinnedNote.copyWith(pinned: false);
      expect(unpinnedNote.pinned, isFalse);
    });
  });
}
}
